---
title: "2024_02_08_ASO_Biotin_pulldown_Data_processing"
output: html_notebook
---



```{r}
library(ggplot2)
library(MSnbase)
library(biobroom)
library(camprotR)
library(Proteomics.analysis.data)
library(dplyr)
library(tidyr)
library(here)
library(DEqMS)
library(limma)
library(broom)


```

Input data

```{r}
pep_data <- read.delim(here("2024_02_13_Peptide_data.txt"))

```


filter crap proteins

```{r}
crap_fasta_inf <-here('2023_02_CCP_cRAP.fasta.gz')

# Load the cRAP FASTA used for the PD search
crap_fasta <- Biostrings::fasta.index(crap_fasta_inf, seqtype = "AA")

# Extract the UniProt accessions associated with each cRAP protein
crap_accessions <- crap_fasta %>%
  pull(desc) %>%
  stringr::str_extract_all(pattern="(?<=\\|).*?(?=\\|)") %>%
  unlist()
```

```{r}
pep_data_flt <- camprotR::parse_features(
  pep_data,
  level = 'peptide',
  crap_proteins = crap_accessions,
)

#level = 'peptide': This parameter specifies that you're interested in parsing peptide-level features from pep_data.
#crap_proteins = crap_accessions: This parameter seems to specify a vector (crap_accessions) containing protein accessions that are considered contaminants or irrelevant for your analysis. The function likely filters out peptides associated with these proteins.
```

```{r}
sample_data <-read.csv("Sample_data.csv")

# Displaying the table in a nicer format
knitr::kable(sample_data,
             align = "cccc",
             format = "html",
             table.attr = "style='width:30%;'")
```


Convert to an MsnSet

```{r}
#select columns with the word "abundance" in.
#setNames(sample_data$Sample): This sets the column names of the selected columns to be equal to the values in the "Sample" column of another dataframe or vector called sample_data.
exprs_data <- read.csv("Exprs_Matrix.csv") %>%
  setNames(sample_data$Sample) %>%
   as.matrix()


# Create data.frame with sample metadata (pData)
#takes sample data and selects every column without "file" in the name, then creates a tibble with the rownames as the column "sample"
pheno_data <- sample_data %>%
  select(-File) %>%
  tibble::column_to_rownames(var = "Sample")

# Create data.frame with peptide metadata (fData)
# select all columns except those with abundance in the name.
feature_data <- pep_data %>%
  select(-matches("Abundance"))

# Create MSnSet
pep <- MSnbase::MSnSet(exprs = exprs_data,
                       fData = feature_data,
                       pData = pheno_data)
```


Let's QC the peptides
```{r}
pep %>%
  log(base = 2) %>%
  camprotR::plot_quant(method = 'box')
```


let's look at some cool peptide intensities
```{r}
pep %>%
  log(base = 2) %>%
  camprotR::plot_quant(method = 'density')
```

```{r}
p <- MSnbase::plotNA(pep, pNA = 0) +
  camprotR::theme_camprot(border = FALSE, base_family = 'sans', base_size = 10) +
  labs(x = 'Peptide index')
```

```{r}
missing_data <- pep %>%
  exprs() %>%
  data.frame()

naniar::gg_miss_upset(missing_data,
                      sets = paste0(colnames(pep), '_NA'),
                      keep.order = TRUE,
                      nsets = 10)
```


I Don't think we need to do any normalising to peptide intensities because we didn't inject the same amount of peptide, it's a pulldown.


Let's do some summarising to protein-level abundances

```{r}
pep_restricted <- pep %>%
  # Maximum 4/8 missing values
  MSnbase::filterNA(pNA = 4/8) %>%

  # At least two peptides per protein
  camprotR::restrict_features_per_protein(min_features = 3, plot = FALSE) %>%

  # Repeat the filtering since restrict_features_per_protein will replace some values with NA
  MSnbase::filterNA(pNA = 4/8) %>%

  camprotR::restrict_features_per_protein(min_features = 3, plot = FALSE)
```

```{r}
p <- MSnbase::plotNA(pep_restricted, pNA = 0) +
  camprotR::theme_camprot(border = FALSE, base_family = 'sans', base_size = 15) +
  labs(x = 'Peptide index')
```


```{r}
prot_robust <- pep_restricted %>%
  MSnbase::combineFeatures(
    # group the peptides by their master protein id
    groupBy = fData(pep_restricted)$Master.Protein.Accessions,
    method = 'robust',
    maxit = 1000  # Ensures convergence for MASS::rlm
  )
#> Your data contains missing values. Please read the relevant section in
#> the combineFeatures manual page for details on the effects of missing
#> values on data aggregation.
```

```{r}
p <- MSnbase::plotNA(prot_robust, pNA = 0) +
  camprotR::theme_camprot(border = FALSE, base_family = 'sans', base_size = 15)
```

```{r}
naniar::gg_miss_upset(data.frame(exprs(prot_robust)),
                      sets = paste0(colnames(prot_robust), '_NA'),
                      keep.order = TRUE,
                      nsets = 10)
```


```{r}
saveRDS(prot_robust, 'lfq_prot_robust.rds')
```

Shall we do some statistical testing?

Load in the QC'd LFQ data from the rds from before
```{r}
lfq_protein <- readRDS('lfq_prot_robust.rds')
```


Tidy up the data
```{r}
lfq_protein_tidy <- lfq_protein %>%
  #make the MSnSet into tidy format for further testing
  biobroom::tidy.MSnSet() %>%
  #Separate the column VEH_NC_1 into three different columns called treatment, CL and replicate
  separate(sample.id, into=c('Treatment', 'CL', 'replicate')) %>%
  #Take the inputs of CL and NCL, make them columns next to each other and list the abundances side by side
  pivot_wider(names_from=CL, values_from=value) %>%
  filter(is.finite(NC), is.finite(CL)) %>%
  group_by(protein) %>%
  #make sure it appears at least twice
  filter(length(protein)>=2)
```

Overall, this code appears to be preparing the protein expression data for further analysis, possibly for downstream statistical analysis or visualization. The filtered_lfq_protein object seems to be a structured data object suitable for analysis in R, potentially for tasks like differential expression analysis or clustering.

```{r}
filtered_exprs <- lfq_protein_tidy %>%
  
  pivot_longer(cols=c(CL, NC), names_to='CL') %>%
  
  mutate(sample=paste0(Treatment, '_', CL, '_', replicate)) %>%
  pivot_wider(names_from=sample, values_from=value, id_cols=protein) %>%
  tibble::column_to_rownames('protein') %>%
  as.matrix()

filtered_lfq_protein <- MSnSet(exprs=filtered_exprs,
                               fData=fData(lfq_protein)[rownames(filtered_exprs),],
                               pData=pData(lfq_protein)[colnames(filtered_exprs),])
```


```{r}
exprs_for_limma <- exprs(filtered_lfq_protein)

# Performing the equivalent of a two-sample t-test
condition <- pData(filtered_lfq_protein)$Condition
replicate <- pData(filtered_lfq_protein)$Replicate

limma_design <- model.matrix(formula(~replicate+condition))

limma_fit <- lmFit(exprs_for_limma, limma_design)
limma_fit <- eBayes(limma_fit, trend=TRUE)
```


```{r}
limma::plotSA(limma_fit)
```
Tom said to ignore the limma results, i just need to create the object using the limma code for DEqMS

```{r}
filtered_lfq_protein_long <- filtered_lfq_protein %>%
  exprs() %>%
  data.frame() %>%
  tibble::rownames_to_column('Master.Protein.Accessions') %>%
  pivot_longer(cols=-Master.Protein.Accessions, values_to='abundance', names_to='sample')
```


```{r}

# Obtain the min peptide count across the samples and determine the minimum value across
# samples
min_pep_count <- camprotR::count_features_per_protein(prot_robust) %>%
  merge(filtered_lfq_protein_long, by=c('Master.Protein.Accessions', 'sample')) %>%
  filter(is.finite(abundance)) %>%  # We only want to consider samples with a ratio quantified
  group_by(Master.Protein.Accessions) %>%
  summarise(min_pep_count = min(n))

# add the min peptide count
limma_fit$count <- min_pep_count$min_pep_count
```

```{r}
efit_deqms <- suppressWarnings(spectraCounteBayes(limma_fit))
```

```{r}
VarianceBoxplot(efit_deqms, n = 30, xlab = "Peptides")
```


```{r}
deqms_results <- outputResult(efit_deqms, coef_col=3)


table(deqms_results$sca.adj.pva<0.01)
#> 
#> FALSE  TRUE 
#>   267   130


deqms_results %>%
  ggplot(aes(x = logFC, y = -log10(sca.P.Value), colour = sca.adj.pval < 0.01)) +
  geom_point() +
  theme_camprot(border=FALSE, base_size=15) +
  scale_colour_manual(values = c('grey', get_cat_palette(2)[2]), name = 'RNase +/- Sig.') +
  labs(x = 'RNase +/- (Log2)', y = '-log10(p-value)')
```


